## TCP 三次握手和四次挥手？

### 三次握手

![](https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.png)

- 客户端发送 SYN 给服务器，说明客户端请求建立连接；
- 服务端收到客户端发的 SYN，并回复 SYN+ACK 给客户端（同意建立连接）；
- 客户端收到服务端的 SYN+ACK 后，回复 ACK 给服务端（表示客户端收到了服务端发的同意报文）；
- 服务端收到客户端的 ACK，连接已建立，可以数据传输。

## TCP 为什么要进行三次握手？

【答案一】因为信道不可靠，而 TCP 想在不可靠信道上建立可靠地传输，那么三次通信是理论上的最小值。（而 UDP 则不需建立可靠传输，因此 UDP 不需要三次握手。）

【答案二】因为双方都需要确认对方收到了自己发送的序列号，确认过程最少要进行三次通信。

【答案三】为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

### 四次分手

![](https://raw.githubusercontent.com/huihut/interview/master/images/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E9%87%8A%E6%94%BE%E8%BF%9E%E6%8E%A5.png)

- 客户端发送 FIN 给服务器，说明客户端不必发送数据给服务器了（请求释放从客户端到服务器的连接）；
- 服务器接收到客户端发的 FIN，并回复 ACK 给客户端（同意释放从客户端到服务器的连接）；
- 客户端收到服务端回复的 ACK，此时从客户端到服务器的连接已释放（但服务端到客户端的连接还未释放，并且客户端还可以接收数据）；
- 服务端继续发送之前没发完的数据给客户端；
- 服务端发送 FIN+ACK 给客户端，说明服务端发送完了数据（请求释放从服务端到客户端的连接，就算没收到客户端的回复，过段时间也会自动释放）；
- 客户端收到服务端的 FIN+ACK，并回复 ACK 给客户端（同意释放从服务端到客户端的连接）；
- 服务端收到客户端的 ACK 后，释放从服务端到客户端的连接。

## TCP 为什么要进行四次挥手？

【问题一】TCP 为什么要进行四次挥手？ / 为什么 TCP 建立连接需要三次，而释放连接则需要四次？

【答案一】因为 TCP 是全双工模式，客户端请求关闭连接后，客户端向服务端的连接关闭（一二次挥手），服务端继续传输之前没传完的数据给客户端（数据传输），服务端向客户端的连接关闭（三四次挥手）。所以 TCP 释放连接时服务器的 ACK 和 FIN 是分开发送的（中间隔着数据传输），而 TCP 建立连接时服务器的 ACK 和 SYN 是一起发送的（第二次握手），所以 TCP 建立连接需要三次，而释放连接则需要四次。

【问题二】为什么 TCP 连接时可以 ACK 和 SYN 一起发送，而释放时则 ACK 和 FIN 分开发送呢？（ACK 和 FIN 分开是指第二次和第三次挥手）

【答案二】因为客户端请求释放时，服务器可能还有数据需要传输给客户端，因此服务端要先响应客户端 FIN 请求（服务端发送 ACK），然后数据传输，传输完成后，服务端再提出 FIN 请求（服务端发送 FIN）；而连接时则没有中间的数据传输，因此连接时可以 ACK 和 SYN 一起发送。

【问题三】为什么客户端释放最后需要 TIME-WAIT 等待 2MSL 呢？

【答案三】

1. 为了保证客户端发送的最后一个 ACK 报文能够到达服务端。若未成功到达，则服务端超时重传 FIN+ACK 报文段，客户端再重传 ACK，并重新计时。
2. 防止已失效的连接请求报文段出现在本连接中。TIME-WAIT 持续 2MSL 可使本连接持续的时间内所产生的所有报文段都从网络中消失，这样可使下次连接中不会出现旧的连接报文段。

## Other

### 为什么不是两次或者四次？

- TCP作为一种可靠传输控制协议，其**核心思想：既要保证数据可靠传输，又要提高传输的效率，而用三次恰恰可以满足以上两方面的需求！**
- 四次握手的过程：很显然2和3这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率。
  - A发送同步信号SYN + A's Initial sequence number；
  - B确认收到A的同步信号，并记录A's ISN到本地，命名B's ACK sequence number；
  - B发送同步信号SYN + B's Initial sequence number；
  - A确认收到B的同步信号，并记录B's ISN到本地，命名A's ACK sequence number。
- 二次握手的过程：A与B就A的初始序列号达成一致，但B无法知道A是否已经接受到自己的同步信号，如果这个同步信号丢失，A和B就B的初始序列号将无法达成一致。
  - A发送同步信号SYN + A's Initial sequence number；
  - B发送同步信号SYN + B's Initial sequence number + B's ACK sequence number。

### TCP可靠传输的精髓

- TCP连接的一方A，由操作系统动态随机选取一个32位长的序列号(Initial Sequence Number)，假设A的初始序列号为1000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，1001，1002，1003..... 并把自己的初始序列号ISN告诉B，让B有个思想准备，什么样编号的数据是合法的，什么编号是非法的，比如编号900就是非法的，同时B还可以对A每一个编号的字节数据进行确认。如果A收到B确认编号为2001,则意味着字节编号为1001-2000，共1000个字节已经安全到达。
- 同理B也是类似的操作，假设B的初始序列号ISN为2000，以该序列号为原点，对自己将要发送的每个字节的数据进行编号，2001，2002，2003..... 并把自己的初始序列号ISN告诉A，以便A可以确认B发送的每一个字节。如果B收到A确认编号为4001,则意味着字节编号为2001-4000，共2000个字节已经安全到达。
- 一句话概括，TCP连接握手，握的是啥？**通信双方数据原点的序列号！**